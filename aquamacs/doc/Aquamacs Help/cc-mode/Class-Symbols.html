<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 16.1), see www.w3.org" />

  <title>Class Symbols - CC Mode Manual</title>
  <meta http-equiv="Content-Type" content="text/html" />
  <meta name="description" content="CC Mode Manual" />
  <meta name="generator" content="makeinfo 4.13" />
  <link title="Top" rel="start" href="index.html#Top" />
  <link rel="up" href="Syntactic-Symbols.html#Syntactic-Symbols"
  title="Syntactic Symbols" />
  <link rel="prev" href="Function-Symbols.html#Function-Symbols"
  title="Function Symbols" />
  <link rel="next" href=
  "Conditional-Construct-Symbols.html#Conditional-Construct-Symbols"
  title="Conditional Construct Symbols" />
  <link href="http://www.gnu.org/software/texinfo/" rel=
  "generator-home" title="Texinfo Homepage" /><!--
This manual is for CC Mode in Emacs.

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being ``A GNU Manual'', and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License''.

     (a) The FSF's Back-Cover Text is: ``You have the freedom to copy
     and modify this GNU manual.  Buying copies from the FSF supports
     it in developing GNU and promoting software freedom.''
   -->
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <style type="text/css">
/*<![CDATA[*/
  <!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; }
  span.sansserif { font-family:sans-serif; font-weight:normal; }
  -->
  /*]]>*/
  </style>
</head>

<body>
  <div class="node">
    <a name="Class-Symbols" id="Class-Symbols"></a>

    <p>Next:&nbsp;<a rel="next" accesskey="n" href=
    "Conditional-Construct-Symbols.html#Conditional-Construct-Symbols">Conditional
    Construct Symbols</a>, Previous:&nbsp;<a rel="previous"
    accesskey="p" href=
    "Function-Symbols.html#Function-Symbols">Function Symbols</a>,
    Up:&nbsp;<a rel="up" accesskey="u" href=
    "Syntactic-Symbols.html#Syntactic-Symbols">Syntactic
    Symbols</a></p>
    <hr />
  </div><!-- node-name, next, previous, up -->

  <h4 class="subsection">10.2.2 Class related Symbols</h4>
  <!-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -->

  <p>Here's an example which illustrates some C++ class syntactic
  symbols:</p>
  <pre class="example">
      1: class Bass
      2:     : public Guitar,
      3:       public Amplifiable
      4: {
      5: public:
      6:     Bass()
      7:         : eString( new BassString( 0.105 )),
      8:           aString( new BassString( 0.085 )),
      9:           dString( new BassString( 0.065 )),
     10:           gString( new BassString( 0.045 ))
     11:     {
     12:         eString.tune( 'E' );
     13:         aString.tune( 'A' );
     14:         dString.tune( 'D' );
     15:         gString.tune( 'G' );
     16:     }
     17:     friend class Luthier;
     18: };
</pre>

  <p><a name="index-class_002dopen-407" id=
  "index-class_002dopen-407"></a><a name=
  "index-class_002dclose-408" id="index-class_002dclose-408"></a>As
  in the previous example, line 1 has the
  <code>topmost-intro</code> syntax. Here however, the brace that
  opens a C++ class definition on line 4 is assigned the
  <code>class-open</code> syntax. Note that in C++, classes,
  structs, and unions are essentially equivalent syntactically (and
  are very similar semantically), so replacing the
  <code>class</code> keyword in the example above with
  <code>struct</code> or <code>union</code> would still result in a
  syntax of <code>class-open</code> for line 4 <a rel="footnote"
  href="#fn-1" name="fnd-1" id="fnd-1"><sup>1</sup></a>. Similarly,
  line 18 is assigned <code>class-close</code> syntax.</p>

  <p><a name="index-inher_002dintro-409" id=
  "index-inher_002dintro-409"></a><a name=
  "index-inher_002dcont-410" id="index-inher_002dcont-410"></a>Line
  2 introduces the inheritance list for the class so it is assigned
  the <code>inher-intro</code> syntax, and line 3, which continues
  the inheritance list is given <code>inher-cont</code> syntax.</p>

  <p><a name="index-access_002dlabel-411" id=
  "index-access_002dlabel-411"></a><a name="index-inclass-412" id=
  "index-inclass-412"></a>Hitting <kbd>C-c C-s</kbd> on line 5
  shows the following analysis:</p>
  <pre class="example">
     ((inclass 58) (access-label 58))
</pre>

  <p class="noindent">The primary syntactic symbol for this line is
  <code>access-label</code> as this is a label keyword that
  specifies access protection in C++. However, because this line is
  also a top-level construct inside a class definition, the
  analysis actually shows two syntactic symbols. The other
  syntactic symbol assigned to this line is <code>inclass</code>.
  Similarly, line 6 is given both <code>inclass</code> and
  <code>topmost-intro</code> syntax:</p>
  <pre class="example">
     ((inclass 58) (topmost-intro 60))
</pre>

  <p><a name="index-member_002dinit_002dintro-413" id=
  "index-member_002dinit_002dintro-413"></a><a name=
  "index-member_002dinit_002dcont-414" id=
  "index-member_002dinit_002dcont-414"></a>Line 7 introduces a C++
  member initialization list and as such is given
  <code>member-init-intro</code> syntax. Note that in this case it
  is <em>not</em> assigned <code>inclass</code> since this is not
  considered a top-level construct. Lines 8 through 10 are all
  assigned <code>member-init-cont</code> since they continue the
  member initialization list started on line 7.</p>

  <p><a name="index-in_002dclass-inline-methods-415" id=
  "index-in_002dclass-inline-methods-415"></a><a name=
  "index-inline_002dopen-416" id=
  "index-inline_002dopen-416"></a><a name=
  "index-inline_002dclose-417" id=
  "index-inline_002dclose-417"></a>Line 11's analysis is a bit more
  complicated:</p>
  <pre class="example">
     ((inclass 58) (inline-open))
</pre>

  <p>This line is assigned a syntax of both
  <code>inline-open</code> and <code>inclass</code> because it
  opens an <dfn>in-class</dfn> C++ inline method definition. This
  is distinct from, but related to, the C++ notion of an inline
  function in that its definition occurs inside an enclosing class
  definition, which in C++ implies that the function should be
  inlined. However, if the definition of the <code>Bass</code>
  constructor appeared outside the class definition, the construct
  would be given the <code>defun-open</code> syntax, even if the
  keyword <code>inline</code> appeared before the method name, as
  in:</p>
  <pre class="example">
      1: class Bass
      2:     : public Guitar,
      3:       public Amplifiable
      4: {
      5: public:
      6:     Bass();
      7: };
      8:
      9: inline
     10: Bass::Bass()
     11:     : eString( new BassString( 0.105 )),
     12:       aString( new BassString( 0.085 )),
     13:       dString( new BassString( 0.065 )),
     14:       gString( new BassString( 0.045 ))
     15: {
     16:     eString.tune( 'E' );
     17:     aString.tune( 'A' );
     18:     dString.tune( 'D' );
     19:     gString.tune( 'G' );
     20: }
</pre>

  <p><a name="index-friend-418" id="index-friend-418"></a>Returning
  to the previous example, line 16 is given
  <code>inline-close</code> syntax, while line 12 is given
  <code>defun-block-open</code> syntax, and lines 13 through 15 are
  all given <code>statement</code> syntax. Line 17 is interesting
  in that its syntactic analysis list contains three elements:</p>
  <pre class="example">
     ((inclass 58) (topmost-intro 380) (friend))
</pre>

  <p>The <code>friend</code> and <code>inline-open</code> syntactic
  symbols are modifiers that do not have anchor positions.</p>

  <p><a name="index-template_002dargs_002dcont-419" id=
  "index-template_002dargs_002dcont-419"></a>Template definitions
  introduce yet another syntactic symbol:</p>
  <pre class="example">
      1: ThingManager &lt;int,
      2:    Framework::Callback *,
      3:    Mutex&gt; framework_callbacks;
</pre>

  <p>Here, line 1 is analyzed as a <code>topmost-intro</code>, but
  lines 2 and 3 are both analyzed as
  <code>template-args-cont</code> lines.
  <!-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! --></p>

  <div class="footnote">
    <hr />

    <h4>Footnotes</h4>

    <p class="footnote"><small>[<a name="fn-1" href="#fnd-1" id=
    "fn-1">1</a>]</small> This is the case even for C and
    Objective-C. For consistency, structs in all supported
    languages are syntactically equivalent to classes. Note however
    that the keyword <code>class</code> is meaningless in C and
    Objective-C.</p>
    <hr />
  </div>
</body>
</html>
