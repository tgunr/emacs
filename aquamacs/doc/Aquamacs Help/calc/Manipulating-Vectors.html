<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 16.1), see www.w3.org" />

  <title>Manipulating Vectors - GNU Emacs Calc Manual</title>
  <meta http-equiv="Content-Type" content="text/html" />
  <meta name="description" content="GNU Emacs Calc Manual" />
  <meta name="generator" content="makeinfo 4.13" />
  <link title="Top" rel="start" href="index.html#Top" />
  <link rel="up" href="Matrix-Functions.html#Matrix-Functions"
  title="Matrix Functions" />
  <link rel="prev" href=
  "Extracting-Elements.html#Extracting-Elements" title=
  "Extracting Elements" />
  <link rel="next" href=
  "Vector-and-Matrix-Arithmetic.html#Vector-and-Matrix-Arithmetic"
  title="Vector and Matrix Arithmetic" />
  <link href="http://www.gnu.org/software/texinfo/" rel=
  "generator-home" title="Texinfo Homepage" /><!--
This file documents Calc, the GNU Emacs calculator, included with
GNU Emacs {No value for `EMACSVER'}.

Copyright (C) 1990, 1991, 2001, 2002, 2003, 2004,
2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being just ``GNU GENERAL
     PUBLIC LICENSE'', with the Front-Cover texts being ``A GNU
     Manual,'' and with the Back-Cover Texts as in (a) below.  A copy
     of the license is included in the section entitled ``GNU Free
     Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have the freedom to copy
     and modify this GNU manual.  Buying copies from the FSF supports
     it in developing GNU and promoting software freedom.''
   -->
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <style type="text/css">
/*<![CDATA[*/
  <!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; }
  span.sansserif { font-family:sans-serif; font-weight:normal; }
  -->
  /*]]>*/
  </style>
</head>

<body>
  <div class="node">
    <a name="Manipulating-Vectors" id="Manipulating-Vectors"></a>

    <p>Next:&nbsp;<a rel="next" accesskey="n" href=
    "Vector-and-Matrix-Arithmetic.html#Vector-and-Matrix-Arithmetic">Vector
    and Matrix Arithmetic</a>, Previous:&nbsp;<a rel="previous"
    accesskey="p" href=
    "Extracting-Elements.html#Extracting-Elements">Extracting
    Elements</a>, Up:&nbsp;<a rel="up" accesskey="u" href=
    "Matrix-Functions.html#Matrix-Functions">Matrix
    Functions</a></p>
    <hr />
  </div>

  <h3 class="section">10.4 Manipulating Vectors</h3>

  <p class="noindent"><a name="index-v-l-1273" id=
  "index-v-l-1273"></a><a name="index-V-l-1274" id=
  "index-V-l-1274"></a><a name="index-calc_002dvlength-1275" id=
  "index-calc_002dvlength-1275"></a><a name="index-vlen-1276" id=
  "index-vlen-1276"></a>The <kbd>v l</kbd>
  (<code>calc-vlength</code>) [<code>vlen</code>] command computes
  the length of a vector. The length of a non-vector is considered
  to be zero. Note that matrices are just vectors of vectors for
  the purposes of this command.</p>

  <p><a name="index-H-v-l-1277" id="index-H-v-l-1277"></a><a name=
  "index-H-V-l-1278" id="index-H-V-l-1278"></a><a name=
  "index-mdims-1279" id="index-mdims-1279"></a>With the Hyperbolic
  flag, <kbd>H v l</kbd> [<code>mdims</code>] computes a vector of
  the dimensions of a vector, matrix, or higher-order object. For
  example, &lsquo;<samp><span class=
  "samp">mdims([[a,b,c],[d,e,f]])</span></samp>&rsquo; returns
  &lsquo;<samp><span class="samp">[2, 3]</span></samp>&rsquo; since
  its argument is a <!-- @math{2\times3} -->
   2x3 matrix.</p>

  <p><a name="index-v-f-1280" id="index-v-f-1280"></a><a name=
  "index-V-f-1281" id="index-V-f-1281"></a><a name=
  "index-calc_002dvector_002dfind-1282" id=
  "index-calc_002dvector_002dfind-1282"></a><a name=
  "index-find-1283" id="index-find-1283"></a>The <kbd>v f</kbd>
  (<code>calc-vector-find</code>) [<code>find</code>] command
  searches along a vector for the first element equal to a given
  target. The target is on the top of the stack; the vector is in
  the second-to-top position. If a match is found, the result is
  the index of the matching element. Otherwise, the result is zero.
  The numeric prefix argument, if given, allows you to select any
  starting index for the search.</p>

  <p><a name="index-v-a-1284" id="index-v-a-1284"></a><a name=
  "index-V-a-1285" id="index-V-a-1285"></a><a name=
  "index-calc_002darrange_002dvector-1286" id=
  "index-calc_002darrange_002dvector-1286"></a><a name=
  "index-arrange-1287" id="index-arrange-1287"></a><a name=
  "index-Arranging-a-matrix-1288" id=
  "index-Arranging-a-matrix-1288"></a><a name=
  "index-Reshaping-a-matrix-1289" id=
  "index-Reshaping-a-matrix-1289"></a><a name=
  "index-Flattening-a-matrix-1290" id=
  "index-Flattening-a-matrix-1290"></a>The <kbd>v a</kbd>
  (<code>calc-arrange-vector</code>) [<code>arrange</code>] command
  rearranges a vector to have a certain number of columns and rows.
  The numeric prefix argument specifies the number of columns; if
  you do not provide an argument, you will be prompted for the
  number of columns. The vector or matrix on the top of the stack
  is <dfn>flattened</dfn> into a plain vector. If the number of
  columns is nonzero, this vector is then formed into a matrix by
  taking successive groups of <var>n</var> elements. If the number
  of columns does not evenly divide the number of elements in the
  vector, the last row will be short and the result will not be
  suitable for use as a matrix. For example, with the matrix
  &lsquo;<samp><span class="samp">[[1, 2], [3,&nbsp;4]
  <!-- /@w -->]</span></samp>&rsquo; on the stack, <kbd>v a 4</kbd>
  produces &lsquo;<samp><span class="samp">[[1, 2, 3,
  4]]</span></samp>&rsquo; (a <!-- @math{1\times4} -->
   1x4 matrix), <kbd>v a 1</kbd> produces &lsquo;<samp><span class=
  "samp">[[1], [2], [3], [4]]</span></samp>&rsquo; (a
  <!-- @math{4\times1} -->
   4x1 matrix), <kbd>v a 2</kbd> produces &lsquo;<samp><span class=
  "samp">[[1, 2], [3, 4]]</span></samp>&rsquo; (the original
  <!-- @math{2\times2} -->
   2x2 matrix), <kbd>v&nbsp;a&nbsp;3</kbd><!-- /@w --> produces
  &lsquo;<samp><span class="samp">[[1, 2, 3],
  [4]]</span></samp>&rsquo; (not a matrix), and <kbd>v a 0</kbd>
  produces the flattened list &lsquo;<samp><span class="samp">[1,
  2, 3,&nbsp;4<!-- /@w -->]</span></samp>&rsquo;.</p>

  <p><a name="index-Sorting-data-1291" id=
  "index-Sorting-data-1291"></a><a name="index-v-S-1292" id=
  "index-v-S-1292"></a><a name="index-V-S-1293" id=
  "index-V-S-1293"></a><a name="index-I-v-S-1294" id=
  "index-I-v-S-1294"></a><a name="index-I-V-S-1295" id=
  "index-I-V-S-1295"></a><a name="index-calc_002dsort-1296" id=
  "index-calc_002dsort-1296"></a><a name="index-sort-1297" id=
  "index-sort-1297"></a><a name="index-rsort-1298" id=
  "index-rsort-1298"></a>The <kbd>V S</kbd>
  (<code>calc-sort</code>) [<code>sort</code>] command sorts the
  elements of a vector into increasing order. Real numbers, real
  infinities, and constant interval forms come first in this
  ordering; next come other kinds of numbers, then variables (in
  alphabetical order), then finally come formulas and other kinds
  of objects; these are sorted according to a kind of lexicographic
  ordering with the useful property that one vector is less or
  greater than another if the first corresponding unequal elements
  are less or greater, respectively. Since quoted strings are
  stored by Calc internally as vectors of ASCII character codes
  (see <a href="Strings.html#Strings">Strings</a>), this means
  vectors of strings are also sorted into alphabetical order by
  this command.</p>

  <p>The <kbd>I V S</kbd> [<code>rsort</code>] command sorts a
  vector into decreasing order.</p>

  <p><a name="index-Permutation_002c-inverse-of-1299" id=
  "index-Permutation_002c-inverse-of-1299"></a><a name=
  "index-Inverse-of-permutation-1300" id=
  "index-Inverse-of-permutation-1300"></a><a name=
  "index-Index-tables-1301" id=
  "index-Index-tables-1301"></a><a name="index-Rank-tables-1302"
  id="index-Rank-tables-1302"></a><a name="index-v-G-1303" id=
  "index-v-G-1303"></a><a name="index-V-G-1304" id=
  "index-V-G-1304"></a><a name="index-I-v-G-1305" id=
  "index-I-v-G-1305"></a><a name="index-I-V-G-1306" id=
  "index-I-V-G-1306"></a><a name="index-calc_002dgrade-1307" id=
  "index-calc_002dgrade-1307"></a><a name="index-grade-1308" id=
  "index-grade-1308"></a><a name="index-rgrade-1309" id=
  "index-rgrade-1309"></a>The <kbd>V G</kbd>
  (<code>calc-grade</code>) [<code>grade</code>,
  <code>rgrade</code>] command produces an index table or
  permutation vector which, if applied to the input vector (as the
  index of <kbd>C-u v r</kbd>, say), would sort the vector. A
  permutation vector is just a vector of integers from 1 to
  <var>n</var>, where each integer occurs exactly once. One
  application of this is to sort a matrix of data rows using one
  column as the sort key; extract that column, grade it with <kbd>V
  G</kbd>, then use the result to reorder the original matrix with
  <kbd>C-u v r</kbd>. Another interesting property of the <code>V
  G</code> command is that, if the input is itself a permutation
  vector, the result will be the inverse of the permutation. The
  inverse of an index table is a rank table, whose <var>k</var>th
  element says where the <var>k</var>th original vector element
  will rest when the vector is sorted. To get a rank table, just
  use <kbd>V G V G</kbd>.</p>

  <p>With the Inverse flag, <kbd>I V G</kbd> produces an index
  table that would sort the input into decreasing order. Note that
  <kbd>V S</kbd> and <kbd>V G</kbd> use a &ldquo;stable&rdquo;
  sorting algorithm, i.e., any two elements which are equal will
  not be moved out of their original order. Generally there is no
  way to tell with <kbd>V S</kbd>, since two elements which are
  equal look the same, but with <kbd>V G</kbd> this can be an
  important issue. In the matrix-of-rows example, suppose you have
  names and telephone numbers as two columns and you wish to sort
  by phone number primarily, and by name when the numbers are
  equal. You can sort the data matrix by names first, and then
  again by phone numbers. Because the sort is stable, any two rows
  with equal phone numbers will remain sorted by name even after
  the second sort.</p>

  <p><a name="index-Histograms-1310" id=
  "index-Histograms-1310"></a><a name="index-v-H-1311" id=
  "index-v-H-1311"></a><a name="index-V-H-1312" id=
  "index-V-H-1312"></a><a name="index-calc_002dhistogram-1313" id=
  "index-calc_002dhistogram-1313"></a><a name=
  "index-histogram-1314" id="index-histogram-1314"></a>The <kbd>V
  H</kbd> (<code>calc-histogram</code>) [<code>histogram</code>]
  command builds a histogram of a vector of numbers. Vector
  elements are assumed to be integers or real numbers in the range
  [0..<var>n</var>) for some &ldquo;number of bins&rdquo;
  <var>n</var>, which is the numeric prefix argument given to the
  command. The result is a vector of <var>n</var> counts of how
  many times each value appeared in the original vector.
  Non-integers in the input are rounded down to integers. Any
  vector elements outside the specified range are ignored. (You can
  tell if elements have been ignored by noting that the counts in
  the result vector don't add up to the length of the input
  vector.)</p>

  <p>If no prefix is given, then you will be prompted for a vector
  which will be used to determine the bins. (If a positive integer
  is given at this prompt, it will be still treated as if it were
  given as a prefix.) Each bin will consist of the interval of
  numbers closest to the corresponding number of this new vector;
  if the vector &lsquo;<samp><span class="samp">[a, b, c,
  ...]</span></samp>&rsquo; is entered at the prompt, the bins will
  be &lsquo;<samp><span class="samp">(-inf,
  (a+b)/2]</span></samp>&rsquo;, &lsquo;<samp><span class=
  "samp">((a+b)/2, (b+c)/2]</span></samp>&rsquo;, etc. The result
  of this command will be a vector counting how many elements of
  the original vector are in each bin.</p>

  <p>The result will then be a vector with the same length as this
  new vector; each element of the new vector will be replaced by
  the number of elements of the original vector which are closest
  to it.</p>

  <p><a name="index-H-v-H-1315" id="index-H-v-H-1315"></a><a name=
  "index-H-V-H-1316" id="index-H-V-H-1316"></a>With the Hyperbolic
  flag, <kbd>H V H</kbd> pulls two vectors from the stack. The
  second-to-top vector is the list of numbers as before. The top
  vector is an equal-sized list of &ldquo;weights&rdquo; to attach
  to the elements of the data vector. For example, if the first
  data element is 4.2 and the first weight is 10, then 10 will be
  added to bin 4 of the result vector. Without the hyperbolic flag,
  every element has a weight of one.</p>

  <p><a name="index-v-t-1317" id="index-v-t-1317"></a><a name=
  "index-V-t-1318" id="index-V-t-1318"></a><a name=
  "index-calc_002dtranspose-1319" id=
  "index-calc_002dtranspose-1319"></a><a name="index-trn-1320" id=
  "index-trn-1320"></a>The <kbd>v t</kbd>
  (<code>calc-transpose</code>) [<code>trn</code>] command computes
  the transpose of the matrix at the top of the stack. If the
  argument is a plain vector, it is treated as a row vector and
  transposed into a one-column matrix.</p>

  <p><a name="index-v-v-1321" id="index-v-v-1321"></a><a name=
  "index-V-v-1322" id="index-V-v-1322"></a><a name=
  "index-calc_002dreverse_002dvector-1323" id=
  "index-calc_002dreverse_002dvector-1323"></a><a name=
  "index-rev-1324" id="index-rev-1324"></a>The <kbd>v v</kbd>
  (<code>calc-reverse-vector</code>) [<code>rev</code>] command
  reverses a vector end-for-end. Given a matrix, it reverses the
  order of the rows. (To reverse the columns instead, just use
  <kbd>v t v v v t</kbd>. The same principle can be used to apply
  other vector commands to the columns of a matrix.)</p>

  <p><a name="index-v-m-1325" id="index-v-m-1325"></a><a name=
  "index-V-m-1326" id="index-V-m-1326"></a><a name=
  "index-calc_002dmask_002dvector-1327" id=
  "index-calc_002dmask_002dvector-1327"></a><a name=
  "index-vmask-1328" id="index-vmask-1328"></a>The <kbd>v m</kbd>
  (<code>calc-mask-vector</code>) [<code>vmask</code>] command uses
  one vector as a mask to extract elements of another vector. The
  mask is in the second-to-top position; the target vector is on
  the top of the stack. These vectors must have the same length.
  The result is the same as the target vector, but with all
  elements which correspond to zeros in the mask vector deleted.
  Thus, for example, &lsquo;<samp><span class="samp">vmask([1, 0,
  1, 0, 1], [a, b, c, d, e])</span></samp>&rsquo; produces
  &lsquo;<samp><span class="samp">[a, c, e]</span></samp>&rsquo;.
  See <a href="Logical-Operations.html#Logical-Operations">Logical
  Operations</a>.</p>

  <p><a name="index-v-e-1329" id="index-v-e-1329"></a><a name=
  "index-V-e-1330" id="index-V-e-1330"></a><a name=
  "index-calc_002dexpand_002dvector-1331" id=
  "index-calc_002dexpand_002dvector-1331"></a><a name=
  "index-vexp-1332" id="index-vexp-1332"></a>The <kbd>v e</kbd>
  (<code>calc-expand-vector</code>) [<code>vexp</code>] command
  expands a vector according to another mask vector. The result is
  a vector the same length as the mask, but with nonzero elements
  replaced by successive elements from the target vector. The
  length of the target vector is normally the number of nonzero
  elements in the mask. If the target vector is longer, its last
  few elements are lost. If the target vector is shorter, the last
  few nonzero mask elements are left unreplaced in the result. Thus
  &lsquo;<samp><span class="samp">vexp([2, 0, 3, 0, 7], [a,
  b])</span></samp>&rsquo; produces &lsquo;<samp><span class=
  "samp">[a, 0, b, 0, 7]</span></samp>&rsquo;.</p>

  <p><a name="index-H-v-e-1333" id="index-H-v-e-1333"></a><a name=
  "index-H-V-e-1334" id="index-H-V-e-1334"></a>With the Hyperbolic
  flag, <kbd>H v e</kbd> takes a filler value from the top of the
  stack; the mask and target vectors come from the third and second
  elements of the stack. This filler is used where the mask is
  zero: &lsquo;<samp><span class="samp">vexp([2, 0, 3, 0, 7], [a,
  b], z)</span></samp>&rsquo; produces &lsquo;<samp><span class=
  "samp">[a, z, c, z, 7]</span></samp>&rsquo;. If the filler value
  is itself a vector, then successive values are taken from it, so
  that the effect is to interleave two vectors according to the
  mask: &lsquo;<samp><span class="samp">vexp([2, 0, 3, 7, 0, 0],
  [a, b], [x, y])</span></samp>&rsquo; produces
  &lsquo;<samp><span class="samp">[a, x, b, 7, y,
  0]</span></samp>&rsquo;.</p>

  <p>Another variation on the masking idea is to combine
  &lsquo;<samp><span class="samp">[a, b, c, d,
  e]</span></samp>&rsquo; with the mask &lsquo;<samp><span class=
  "samp">[1, 0, 1, 0, 1]</span></samp>&rsquo; to produce
  &lsquo;<samp><span class="samp">[a, 0, c, 0,
  e]</span></samp>&rsquo;. You can accomplish this with <kbd>V M a
  &amp;</kbd>, mapping the logical &ldquo;and&rdquo; operation
  across the two vectors. See <a href=
  "Logical-Operations.html#Logical-Operations">Logical
  Operations</a>. Note that the <code>? :</code> operation also
  discussed there allows other types of masking using vectors.</p>
</body>
</html>
