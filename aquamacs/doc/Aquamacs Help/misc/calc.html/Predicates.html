<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<!-- This file documents Calc, the GNU Emacs calculator, included with
GNU Emacs 25.1.

Copyright (C) 1990-1991, 2001-2016 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being just "GNU GENERAL PUBLIC LICENSE", with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the section
entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual." -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->

<head>
  <meta name="generator" content=
  "HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 16.1), see www.w3.org" />

  <title>GNU Emacs Calc Manual: Predicates</title>
  <meta name="description" content=
  "GNU Emacs Calc Manual: Predicates" />
  <meta name="keywords" content=
  "GNU Emacs Calc Manual: Predicates" />
  <meta name="resource-type" content="document" />
  <meta name="distribution" content="global" />
  <meta name="Generator" content="makeinfo" />
  <meta http-equiv="Content-Type" content=
  "text/html; charset=us-ascii" />
  <link href="index.html#Top" rel="start" title="Top" />
  <link href="Key-Index.html#Key-Index" rel="index" title=
  "Key Index" />
  <link href="index.html#SEC_Contents" rel="contents" title=
  "Table of Contents" />
  <link href="Internals.html#Internals" rel="up" title=
  "Internals" />
  <link href=
  "Computational-Lisp-Functions.html#Computational-Lisp-Functions"
  rel="next" title="Computational Lisp Functions" />
  <link href="Stack-Lisp-Functions.html#Stack-Lisp-Functions" rel=
  "prev" title="Stack Lisp Functions" />
  <style type="text/css">
/*<![CDATA[*/
  <!--
  a.summary-letter {text-decoration: none}
  blockquote.smallquotation {font-size: smaller}
  div.display {margin-left: 3.2em}
  div.example {margin-left: 3.2em}
  div.indentedblock {margin-left: 3.2em}
  div.lisp {margin-left: 3.2em}
  div.smalldisplay {margin-left: 3.2em}
  div.smallexample {margin-left: 3.2em}
  div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
  div.smalllisp {margin-left: 3.2em}
  kbd {font-style:oblique}
  pre.display {font-family: inherit}
  pre.format {font-family: inherit}
  pre.menu-comment {font-family: serif}
  pre.menu-preformatted {font-family: serif}
  pre.smalldisplay {font-family: inherit; font-size: smaller}
  pre.smallexample {font-size: smaller}
  pre.smallformat {font-family: inherit; font-size: smaller}
  pre.smalllisp {font-size: smaller}
  span.nocodebreak {white-space:nowrap}
  span.nolinebreak {white-space:nowrap}
  span.roman {font-family:serif; font-weight:normal}
  span.sansserif {font-family:sans-serif; font-weight:normal}
  ul.no-bullet {list-style: none}
  -->
  /*]]>*/
  </style>
  <style type="text/css">
/*<![CDATA[*/
  body {
  background-color: #FFFFFF;
  color: #000000;
  }
  :link { color: #0000FF }
  :visited { color: #800080 }
  :active { color: #FF0000 }
  /*]]>*/
  </style>
</head>

<body lang="en" xml:lang="en">
  <a name="Predicates" id="Predicates"></a>

  <div class="header">
    <p>Next: <a href=
    "Computational-Lisp-Functions.html#Computational-Lisp-Functions"
    accesskey="n" rel="next">Computational Lisp Functions</a>,
    Previous: <a href=
    "Stack-Lisp-Functions.html#Stack-Lisp-Functions" accesskey="p"
    rel="prev">Stack Lisp Functions</a>, Up: <a href=
    "Internals.html#Internals" accesskey="u" rel="up">Internals</a>
    &nbsp; [<a href="index.html#SEC_Contents" title=
    "Table of contents" rel="contents">Contents</a>][<a href=
    "Key-Index.html#Key-Index" title="Index" rel=
    "index">Index</a>]</p>
  </div>
  <hr />
  <a name="Predicates-2" id="Predicates-2"></a>

  <h4 class="subsubsection">17.5.7.4 Predicates</h4>

  <p>The functions described here are predicates, that is, they
  return a true/false value where <code>nil</code> means false and
  anything else means true. These predicates are expanded by
  <code>defmath</code>, for example, from <code>zerop</code> to
  <code>math-zerop</code>. In many cases they correspond to native
  Lisp functions by the same name, but are extended to cover the
  full range of Calc data types.</p>

  <dl>
    <dt><a name="index-zerop" id="index-zerop"></a>Function:
    <strong>zerop</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is numerically zero, in any
      of the Calc data types. (Note that for some types, such as
      error forms and intervals, it never makes sense to return
      true.) In <code>defmath</code>, the expression
      &lsquo;<samp>(= x 0)</samp>&rsquo; will automatically be
      converted to &lsquo;<samp>(math-zerop x)</samp>&rsquo;, and
      &lsquo;<samp>(/= x 0)</samp>&rsquo; will be converted to
      &lsquo;<samp>(not (math-zerop x))</samp>&rsquo;.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-negp" id="index-negp"></a>Function:
    <strong>negp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is negative. This accepts
      negative real numbers of various types, negative HMS and date
      forms, and intervals in which all included values are
      negative. In <code>defmath</code>, the expression
      &lsquo;<samp>(&lt; x 0)</samp>&rsquo; will automatically be
      converted to &lsquo;<samp>(math-negp x)</samp>&rsquo;, and
      &lsquo;<samp>(&gt;= x 0)</samp>&rsquo; will be converted to
      &lsquo;<samp>(not (math-negp x))</samp>&rsquo;.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-posp" id="index-posp"></a>Function:
    <strong>posp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is positive (and non-zero).
      For complex numbers, none of these three predicates will
      return true.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-looks_002dnegp" id=
    "index-looks_002dnegp"></a>Function:
    <strong>looks-negp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is
      &ldquo;negative-looking.&rdquo; This returns true if
      <var>x</var> is a negative number, or a formula with a
      leading minus sign such as &lsquo;<samp>-a/b</samp>&rsquo;.
      In other words, this is an object which can be made simpler
      by calling <code>(- <var>x</var>)</code>.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-integerp" id="index-integerp"></a>Function:
    <strong>integerp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is an integer of any
      size.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-fixnump" id="index-fixnump"></a>Function:
    <strong>fixnump</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a native Lisp integer.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-natnump" id="index-natnump"></a>Function:
    <strong>natnump</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a nonnegative integer of
      any size.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-fixnatnump" id=
    "index-fixnatnump"></a>Function: <strong>fixnatnump</strong>
    <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a nonnegative Lisp
      integer.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-num_002dintegerp" id=
    "index-num_002dintegerp"></a>Function:
    <strong>num-integerp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is numerically an integer,
      i.e., either a true integer or a float with no significant
      digits to the right of the decimal point.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-messy_002dintegerp" id=
    "index-messy_002dintegerp"></a>Function:
    <strong>messy-integerp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is numerically, but not
      literally, an integer. A value is <code>num-integerp</code>
      if it is <code>integerp</code> or <code>messy-integerp</code>
      (but it is never both at once).</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-num_002dnatnump" id=
    "index-num_002dnatnump"></a>Function:
    <strong>num-natnump</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is numerically a nonnegative
      integer.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-evenp" id="index-evenp"></a>Function:
    <strong>evenp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is an even integer.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-looks_002devenp" id=
    "index-looks_002devenp"></a>Function:
    <strong>looks-evenp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is an even integer, or a
      formula with a leading multiplicative coefficient which is an
      even integer.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-oddp" id="index-oddp"></a>Function:
    <strong>oddp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is an odd integer.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-ratp" id="index-ratp"></a>Function:
    <strong>ratp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a rational number, i.e.,
      an integer or a fraction.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-realp" id="index-realp"></a>Function:
    <strong>realp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a real number, i.e., an
      integer, fraction, or floating-point number.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-anglep" id="index-anglep"></a>Function:
    <strong>anglep</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a real number or HMS
      form.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-floatp" id="index-floatp"></a>Function:
    <strong>floatp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a float, or a complex
      number, error form, interval, date form, or modulo form in
      which at least one component is a float.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-complexp" id="index-complexp"></a>Function:
    <strong>complexp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a rectangular or polar
      complex number (but not a real number).</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-rect_002dcomplexp" id=
    "index-rect_002dcomplexp"></a>Function:
    <strong>rect-complexp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a rectangular complex
      number.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-polar_002dcomplexp" id=
    "index-polar_002dcomplexp"></a>Function:
    <strong>polar-complexp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a polar complex
      number.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-numberp" id="index-numberp"></a>Function:
    <strong>numberp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a real number or a complex
      number.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-scalarp" id="index-scalarp"></a>Function:
    <strong>scalarp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a real or complex number
      or an HMS form.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-vectorp" id="index-vectorp"></a>Function:
    <strong>vectorp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a vector (this simply
      checks if its argument is a list whose first element is the
      symbol <code>vec</code>).</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-numvecp" id="index-numvecp"></a>Function:
    <strong>numvecp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a number or vector.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-matrixp" id="index-matrixp"></a>Function:
    <strong>matrixp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a matrix, i.e., a vector
      of one or more vectors, all of the same size.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-square_002dmatrixp" id=
    "index-square_002dmatrixp"></a>Function:
    <strong>square-matrixp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a square matrix.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-objectp" id="index-objectp"></a>Function:
    <strong>objectp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is any numeric Calc object,
      including real and complex numbers, HMS forms, date forms,
      error forms, intervals, and modulo forms. (Note that error
      forms and intervals may include formulas as their components;
      see <code>constp</code> below.)</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-objvecp" id="index-objvecp"></a>Function:
    <strong>objvecp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is an object or a vector.
      This also accepts incomplete objects, but it rejects
      variables and formulas (except as mentioned above for
      <code>objectp</code>).</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-primp" id="index-primp"></a>Function:
    <strong>primp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is a &ldquo;primitive&rdquo;
      or &ldquo;atomic&rdquo; Calc object, i.e., one whose
      components cannot be regarded as sub-formulas. This includes
      variables, and all <code>objectp</code> types except error
      forms and intervals.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-constp" id="index-constp"></a>Function:
    <strong>constp</strong> <em>x</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is constant, i.e., a real or
      complex number, HMS form, date form, or error form, interval,
      or vector all of whose components are
      <code>constp</code>.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-lessp" id="index-lessp"></a>Function:
    <strong>lessp</strong> <em>x y</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is numerically less than
      <var>y</var>. Returns false if <var>x</var> is greater than
      or equal to <var>y</var>, or if the order is undefined or
      cannot be determined. Generally speaking, this works by
      checking whether &lsquo;<samp><var>x</var> -
      <var>y</var></samp>&rsquo; is <code>negp</code>. In
      <code>defmath</code>, the expression &lsquo;<samp>(&lt; x
      y)</samp>&rsquo; will automatically be converted to
      &lsquo;<samp>(lessp x y)</samp>&rsquo;; expressions involving
      <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>
      are similarly converted in terms of <code>lessp</code>.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-beforep" id="index-beforep"></a>Function:
    <strong>beforep</strong> <em>x y</em></dt>

    <dd>
      <p>Returns true if <var>x</var> comes before <var>y</var> in
      a canonical ordering of Calc objects. If <var>x</var> and
      <var>y</var> are both real numbers, this will be the same as
      <code>lessp</code>. But whereas <code>lessp</code> considers
      other types of objects to be unordered, <code>beforep</code>
      puts any two objects into a definite, consistent order. The
      <code>beforep</code> function is used by the <kbd>V S</kbd>
      vector-sorting command, and also by Calc&rsquo;s algebraic
      simplifications to put the terms of a product into canonical
      order: This allows &lsquo;<samp>x y + y x</samp>&rsquo; to be
      simplified easily to &lsquo;<samp>2 x y</samp>&rsquo;.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-equal" id="index-equal"></a>Function:
    <strong>equal</strong> <em>x y</em></dt>

    <dd>
      <p>This is the standard Lisp <code>equal</code> predicate; it
      returns true if <var>x</var> and <var>y</var> are
      structurally identical. This is the usual way to compare
      numbers for equality, but note that <code>equal</code> will
      treat 0 and 0.0 as different.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-math_002dequal" id=
    "index-math_002dequal"></a>Function:
    <strong>math-equal</strong> <em>x y</em></dt>

    <dd>
      <p>Returns true if <var>x</var> and <var>y</var> are
      numerically equal, either because they are
      <code>equal</code>, or because their difference is
      <code>zerop</code>. In <code>defmath</code>, the expression
      &lsquo;<samp>(= x y)</samp>&rsquo; will automatically be
      converted to &lsquo;<samp>(math-equal x y)</samp>&rsquo;.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-equal_002dint" id=
    "index-equal_002dint"></a>Function: <strong>equal-int</strong>
    <em>x n</em></dt>

    <dd>
      <p>Returns true if <var>x</var> and <var>n</var> are
      numerically equal, where <var>n</var> is a fixnum which is
      not a multiple of 10. This will automatically be used by
      <code>defmath</code> in place of the more general
      <code>math-equal</code> whenever possible.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-nearly_002dequal" id=
    "index-nearly_002dequal"></a>Function:
    <strong>nearly-equal</strong> <em>x y</em></dt>

    <dd>
      <p>Returns true if <var>x</var> and <var>y</var>, as
      floating-point numbers, are equal except possibly in the last
      decimal place. For example, 314.159 and 314.166 are
      considered nearly equal if the current precision is 6 (since
      they differ by 7 units), but not if the current precision is
      7 (since they differ by 70 units). Most functions which use
      series expansions use <code>with-extra-prec</code> to
      evaluate the series with 2 extra digits of precision, then
      use <code>nearly-equal</code> to decide when the series has
      converged; this guards against cumulative error in the series
      evaluation without doing extra work which would be lost when
      the result is rounded back down to the current precision. In
      <code>defmath</code>, this can be written &lsquo;<samp>(~=
      <var>x</var> <var>y</var>)</samp>&rsquo;. The <var>x</var>
      and <var>y</var> can be numbers of any kind, including
      complex.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-nearly_002dzerop" id=
    "index-nearly_002dzerop"></a>Function:
    <strong>nearly-zerop</strong> <em>x y</em></dt>

    <dd>
      <p>Returns true if <var>x</var> is nearly zero, compared to
      <var>y</var>. This checks whether <var>x</var> plus
      <var>y</var> would by be <code>nearly-equal</code> to
      <var>y</var> itself, to within the current precision, in
      other words, if adding <var>x</var> to <var>y</var> would
      have a negligible effect on <var>y</var> due to roundoff
      error. <var>X</var> may be a real or complex number, but
      <var>y</var> must be real.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-is_002dtrue" id=
    "index-is_002dtrue"></a>Function: <strong>is-true</strong>
    <em>x</em></dt>

    <dd>
      <p>Return true if the formula <var>x</var> represents a true
      value in Calc, not Lisp, terms. It tests if <var>x</var> is a
      non-zero number or a provably non-zero formula.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-reject_002darg" id=
    "index-reject_002darg"></a>Function:
    <strong>reject-arg</strong> <em>val pred</em></dt>

    <dd>
      <p>Abort the current function evaluation due to unacceptable
      argument values. This calls &lsquo;<samp>(calc-record-why
      <var>pred</var> <var>val</var>)</samp>&rsquo;, then signals a
      Lisp error which <code>normalize</code> will trap. The net
      effect is that the function call which led here will be left
      in symbolic form.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-inexact_002dvalue" id=
    "index-inexact_002dvalue"></a>Function:
    <strong>inexact-value</strong></dt>

    <dd>
      <p>If Symbolic mode is enabled, this will signal an error
      that causes <code>normalize</code> to leave the formula in
      symbolic form, with the message &ldquo;Inexact result.&rdquo;
      (This function has no effect when not in Symbolic mode.) Note
      that if your function calls &lsquo;<samp>(sin
      5)</samp>&rsquo; in Symbolic mode, the <code>sin</code>
      function will call <code>inexact-value</code>, which will
      cause your function to be left unsimplified. You may instead
      wish to call &lsquo;<samp>(normalize (list 'calcFunc-sin
      5))</samp>&rsquo;, which in Symbolic mode will return the
      formula &lsquo;<samp>sin(5)</samp>&rsquo; to your
      function.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-overflow" id="index-overflow"></a>Function:
    <strong>overflow</strong></dt>

    <dd>
      <p>This signals an error that will be reported as a
      floating-point overflow.</p>
    </dd>
  </dl>

  <dl>
    <dt><a name="index-underflow" id=
    "index-underflow"></a>Function: <strong>underflow</strong></dt>

    <dd>
      <p>This signals a floating-point underflow.</p>
    </dd>
  </dl>
  <hr />

  <div class="header">
    <p>Next: <a href=
    "Computational-Lisp-Functions.html#Computational-Lisp-Functions"
    accesskey="n" rel="next">Computational Lisp Functions</a>,
    Previous: <a href=
    "Stack-Lisp-Functions.html#Stack-Lisp-Functions" accesskey="p"
    rel="prev">Stack Lisp Functions</a>, Up: <a href=
    "Internals.html#Internals" accesskey="u" rel="up">Internals</a>
    &nbsp; [<a href="index.html#SEC_Contents" title=
    "Table of contents" rel="contents">Contents</a>][<a href=
    "Key-Index.html#Key-Index" title="Index" rel=
    "index">Index</a>]</p>
  </div>
</body>
</html>
