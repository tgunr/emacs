<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<!-- This file documents Calc, the GNU Emacs calculator, included with
GNU Emacs 25.1.

Copyright (C) 1990-1991, 2001-2016 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being just "GNU GENERAL PUBLIC LICENSE", with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the section
entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual." -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->

<head>
  <meta name="generator" content=
  "HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 16.1), see www.w3.org" />

  <title>GNU Emacs Calc Manual: Rewrites Tutorial</title>
  <meta name="description" content=
  "GNU Emacs Calc Manual: Rewrites Tutorial" />
  <meta name="keywords" content=
  "GNU Emacs Calc Manual: Rewrites Tutorial" />
  <meta name="resource-type" content="document" />
  <meta name="distribution" content="global" />
  <meta name="Generator" content="makeinfo" />
  <meta http-equiv="Content-Type" content=
  "text/html; charset=us-ascii" />
  <link href="index.html#Top" rel="start" title="Top" />
  <link href="Key-Index.html#Key-Index" rel="index" title=
  "Key Index" />
  <link href="index.html#SEC_Contents" rel="contents" title=
  "Table of Contents" />
  <link href="Algebra-Tutorial.html#Algebra-Tutorial" rel="up"
  title="Algebra Tutorial" />
  <link href="Programming-Tutorial.html#Programming-Tutorial" rel=
  "next" title="Programming Tutorial" />
  <link href="Basic-Algebra-Tutorial.html#Basic-Algebra-Tutorial"
  rel="prev" title="Basic Algebra Tutorial" />
  <style type="text/css">
/*<![CDATA[*/
  <!--
  a.summary-letter {text-decoration: none}
  blockquote.smallquotation {font-size: smaller}
  div.display {margin-left: 3.2em}
  div.example {margin-left: 3.2em}
  div.indentedblock {margin-left: 3.2em}
  div.lisp {margin-left: 3.2em}
  div.smalldisplay {margin-left: 3.2em}
  div.smallexample {margin-left: 3.2em}
  div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
  div.smalllisp {margin-left: 3.2em}
  kbd {font-style:oblique}
  pre.display {font-family: inherit}
  pre.format {font-family: inherit}
  pre.menu-comment {font-family: serif}
  pre.menu-preformatted {font-family: serif}
  pre.smalldisplay {font-family: inherit; font-size: smaller}
  pre.smallexample {font-size: smaller}
  pre.smallformat {font-family: inherit; font-size: smaller}
  pre.smalllisp {font-size: smaller}
  span.nocodebreak {white-space:nowrap}
  span.nolinebreak {white-space:nowrap}
  span.roman {font-family:serif; font-weight:normal}
  span.sansserif {font-family:sans-serif; font-weight:normal}
  ul.no-bullet {list-style: none}
  -->
  /*]]>*/
  </style>
  <style type="text/css">
/*<![CDATA[*/
  body {
  background-color: #FFFFFF;
  color: #000000;
  }
  :link { color: #0000FF }
  :visited { color: #800080 }
  :active { color: #FF0000 }
  /*]]>*/
  </style>
</head>

<body lang="en" xml:lang="en">
  <a name="Rewrites-Tutorial" id="Rewrites-Tutorial"></a>

  <div class="header">
    <p>Previous: <a href=
    "Basic-Algebra-Tutorial.html#Basic-Algebra-Tutorial" accesskey=
    "p" rel="prev">Basic Algebra Tutorial</a>, Up: <a href=
    "Algebra-Tutorial.html#Algebra-Tutorial" accesskey="u" rel=
    "up">Algebra Tutorial</a> &nbsp; [<a href=
    "index.html#SEC_Contents" title="Table of contents" rel=
    "contents">Contents</a>][<a href="Key-Index.html#Key-Index"
    title="Index" rel="index">Index</a>]</p>
  </div>
  <hr />
  <a name="Rewrite-Rules-1" id="Rewrite-Rules-1"></a>

  <h4 class="subsection">2.5.2 Rewrite Rules</h4>

  <p>No matter how many built-in commands Calc provided for doing
  algebra, there would always be something you wanted to do that
  Calc didn&rsquo;t have in its repertoire. So Calc also provides a
  <em>rewrite rule</em> system that you can use to define your own
  algebraic manipulations.</p>

  <p>Suppose we want to simplify this trigonometric formula:</p>

  <div class="smallexample">
    <pre class="smallexample">
1:  2 sec(x)^2 / tan(x)^2 - 2 / tan(x)^2
    .

    ' 2sec(x)^2/tan(x)^2 - 2/tan(x)^2 <span class=
"key">RET</span>   s 1
</pre>
  </div>

  <p>If we were simplifying this by hand, we&rsquo;d probably
  combine over the common denominator. The <kbd>a n</kbd> algebra
  command will do this, but we&rsquo;ll do it with a rewrite rule
  just for practice.</p>

  <p>Rewrite rules are written with the
  &lsquo;<samp>:=</samp>&rsquo; symbol.</p>

  <div class="smallexample">
    <pre class="smallexample">
1:  (2 sec(x)^2 - 2) / tan(x)^2
    .

    a r a/x + b/x := (a+b)/x <span class="key">RET</span>
</pre>
  </div>

  <p>(The &ldquo;assignment operator&rdquo;
  &lsquo;<samp>:=</samp>&rsquo; has several uses in Calc. All by
  itself the formula &lsquo;<samp>a/x + b/x :=
  (a+b)/x</samp>&rsquo; doesn&rsquo;t do anything, but when it is
  given to the <kbd>a r</kbd> command, that command interprets it
  as a rewrite rule.)</p>

  <p>The lefthand side, &lsquo;<samp>a/x + b/x</samp>&rsquo;, is
  called the <em>pattern</em> of the rewrite rule. Calc searches
  the formula on the stack for parts that match the pattern.
  Variables in a rewrite pattern are called
  <em>meta-variables</em>, and when matching the pattern each
  meta-variable can match any sub-formula. Here, the meta-variable
  &lsquo;<samp>a</samp>&rsquo; matched the expression
  &lsquo;<samp>2 sec(x)^2</samp>&rsquo;, the meta-variable
  &lsquo;<samp>b</samp>&rsquo; matched the constant
  &lsquo;<samp>-2</samp>&rsquo; and the meta-variable
  &lsquo;<samp>x</samp>&rsquo; matched the expression
  &lsquo;<samp>tan(x)^2</samp>&rsquo;.</p>

  <p>This rule points out several interesting features of rewrite
  patterns. First, if a meta-variable appears several times in a
  pattern, it must match the same thing everywhere. This rule
  detects common denominators because the same meta-variable
  &lsquo;<samp>x</samp>&rsquo; is used in both of the
  denominators.</p>

  <p>Second, meta-variable names are independent from variables in
  the target formula. Notice that the meta-variable
  &lsquo;<samp>x</samp>&rsquo; here matches the subformula
  &lsquo;<samp>tan(x)^2</samp>&rsquo;; Calc never confuses the two
  meanings of &lsquo;<samp>x</samp>&rsquo;.</p>

  <p>And third, rewrite patterns know a little bit about the
  algebraic properties of formulas. The pattern called for a sum of
  two quotients; Calc was able to match a difference of two
  quotients by matching &lsquo;<samp>a = 2 sec(x)^2</samp>&rsquo;,
  &lsquo;<samp>b = -2</samp>&rsquo;, and &lsquo;<samp>x =
  tan(x)^2</samp>&rsquo;.</p>

  <p>When the pattern part of a rewrite rule matches a part of the
  formula, that part is replaced by the righthand side with all the
  meta-variables substituted with the things they matched. So the
  result is &lsquo;<samp>(2 sec(x)^2 - 2) /
  tan(x)^2</samp>&rsquo;.</p>

  <p>We could just as easily have written &lsquo;<samp>a/x - b/x :=
  (a-b)/x</samp>&rsquo; for the rule. It would have worked just the
  same in all cases. (If we really wanted the rule to apply only to
  &lsquo;<samp>+</samp>&rsquo; or only to
  &lsquo;<samp>-</samp>&rsquo;, we could have used the
  <code>plain</code> symbol. See <a href=
  "Algebraic-Properties-of-Rewrite-Rules.html#Algebraic-Properties-of-Rewrite-Rules">
  Algebraic Properties of Rewrite Rules</a>, for some examples of
  this.)</p>

  <p>One more rewrite will complete the job. We want to use the
  identity &lsquo;<samp>tan(x)^2 + 1 = sec(x)^2</samp>&rsquo;, but
  of course we must first rearrange the identity in a way that
  matches our formula. The obvious rule would be
  &lsquo;<samp>2&nbsp;sec(x)^2&nbsp;<span class=
  "nolinebreak">-</span>&nbsp;2<!-- /@w --> := 2
  tan(x)^2</samp>&rsquo;, but a little thought shows that the rule
  &lsquo;<samp>sec(x)^2 := 1 + tan(x)^2</samp>&rsquo; will also
  work. The latter rule has a more general pattern so it will work
  in many other situations, too.</p>

  <div class="smallexample">
    <pre class="smallexample">
1:  2
    .

    a r sec(x)^2 := 1 + tan(x)^2 <span class="key">RET</span>
</pre>
  </div>

  <p>You may ask, what&rsquo;s the point of using the most general
  rule if you have to type it in every time anyway? The answer is
  that Calc allows you to store a rewrite rule in a variable, then
  give the variable name in the <kbd>a r</kbd> command. In fact,
  this is the preferred way to use rewrites. For one, if you need a
  rule once you&rsquo;ll most likely need it again later. Also, if
  the rule doesn&rsquo;t work quite right you can simply Undo, edit
  the variable, and run the rule again without having to retype
  it.</p>

  <div class="smallexample">
    <pre class="smallexample">
' a/x + b/x := (a+b)/x <span class=
"key">RET</span>          s t merge <span class="key">RET</span>
' sec(x)^2 := 1 + tan(x)^2 <span class=
"key">RET</span>      s t secsqr <span class="key">RET</span>

1:  2 sec(x)^2 / tan(x)^2 - 2 / tan(x)^2    1:  2
    .                                  .

    r 1                  a r merge <span class=
"key">RET</span>  a r secsqr <span class="key">RET</span>
</pre>
  </div>

  <p>To edit a variable, type <kbd>s e</kbd> and the variable name,
  use regular Emacs editing commands as necessary, then type
  <kbd>C-c C-c</kbd> to store the edited value back into the
  variable. You can also use <kbd>s&nbsp;e</kbd><!-- /@w --> to
  create a new variable if you wish.</p>

  <p>Notice that the first time you use each rule, Calc puts up a
  &ldquo;compiling&rdquo; message briefly. The pattern matcher
  converts rules into a special optimized pattern-matching language
  rather than using them directly. This allows <kbd>a r</kbd> to
  apply even rather complicated rules very efficiently. If the rule
  is stored in a variable, Calc compiles it only once and stores
  the compiled form along with the variable. That&rsquo;s another
  good reason to store your rules in variables rather than entering
  them on the fly.</p>

  <p>(&bull;) <strong>Exercise 1.</strong> Type <kbd>m s</kbd> to
  get Symbolic mode, then enter the formula
  &lsquo;<samp>(2&nbsp;+&nbsp;sqrt(2))<!-- /@w --> /
  (1&nbsp;+&nbsp;sqrt(2))<!-- /@w --></samp>&rsquo;. Using a
  rewrite rule, simplify this formula by multiplying the top and
  bottom by the conjugate &lsquo;<samp>1&nbsp;<span class=
  "nolinebreak">-</span>&nbsp;sqrt(2)</samp>&rsquo;<!-- /@w -->.
  The result will have to be expanded by the distributive law; do
  this with another rewrite. See <a href=
  "Rewrites-Answer-1.html#Rewrites-Answer-1">1</a>. (&bull;)</p>

  <p>The <kbd>a r</kbd> command can also accept a vector of rewrite
  rules, or a variable containing a vector of rules.</p>

  <div class="smallexample">
    <pre class="smallexample">
1:  [merge, secsqr]          1:  [a/x + b/x := (a + b)/x, ... ]
    .                                 .

    ' [merge,sinsqr] <span class="key">RET</span>          =

</pre>
  </div>

  <div class="smallexample">
    <pre class="smallexample">
1:  2 sec(x)^2 / tan(x)^2 - 2 / tan(x)^2     1:  2
    .                                 .

    s t trig <span class=
"key">RET</span>  r 1                  a r trig <span class=
"key">RET</span>
</pre>
  </div>

  <p>Calc tries all the rules you give against all parts of the
  formula, repeating until no further change is possible. (The
  exact order in which things are tried is rather complex, but for
  simple rules like the ones we&rsquo;ve used here the order
  doesn&rsquo;t really matter. See <a href=
  "Nested-Formulas-with-Rewrite-Rules.html#Nested-Formulas-with-Rewrite-Rules">
  Nested Formulas with Rewrite Rules</a>.)</p>

  <p>Calc actually repeats only up to 100 times, just in case your
  rule set has gotten into an infinite loop. You can give a numeric
  prefix argument to <kbd>a r</kbd> to specify any limit. In
  particular, <kbd>M-1 a r</kbd> does only one rewrite at a
  time.</p>

  <div class="smallexample">
    <pre class="smallexample">
1:  (2 sec(x)^2 - 2) / tan(x)^2         1:  2
    .                                       .

    r 1  M-1 a r trig <span class=
"key">RET</span>                   M-1 a r trig <span class=
"key">RET</span>
</pre>
  </div>

  <p>You can type <kbd>M-0 a r</kbd> if you want no limit at all on
  the number of rewrites that occur.</p>

  <p>Rewrite rules can also be <em>conditional</em>. Simply follow
  the rule with a &lsquo;<samp>::</samp>&rsquo; symbol and the
  desired condition. For example,</p>

  <div class="smallexample">
    <pre class="smallexample">
1:  sin(x + 2 pi) + sin(x + 3 pi) + sin(x + 4 pi)
    .

    ' sin(x+2pi) + sin(x+3pi) + sin(x+4pi) <span class=
"key">RET</span>

</pre>
  </div>

  <div class="smallexample">
    <pre class="smallexample">
1:  sin(x + 3 pi) + 2 sin(x)
    .

    a r sin(a + k pi) := sin(a) :: k % 2 = 0 <span class=
"key">RET</span>
</pre>
  </div>

  <p>(Recall, &lsquo;<samp>k % 2</samp>&rsquo; is the remainder
  from dividing &lsquo;<samp>k</samp>&rsquo; by 2, which will be
  zero only when &lsquo;<samp>k</samp>&rsquo; is an even
  integer.)</p>

  <p>An interesting point is that the variable
  &lsquo;<samp>pi</samp>&rsquo; was matched literally rather than
  acting as a meta-variable. This is because it is a
  special-constant variable. The special constants
  &lsquo;<samp>e</samp>&rsquo;, &lsquo;<samp>i</samp>&rsquo;,
  &lsquo;<samp>phi</samp>&rsquo;, and so on also match literally. A
  common error with rewrite rules is to write, say,
  &lsquo;<samp>f(a,b,c,d,e) := g(a+b+c+d+e)</samp>&rsquo;,
  expecting to match any &lsquo;<samp>f</samp>&rsquo; with five
  arguments but in fact matching only when the fifth argument is
  literally &lsquo;<samp>e</samp>&rsquo;!</p><a name=
  "index-Fibonacci-numbers" id="index-Fibonacci-numbers"></a>
  <a name="index-fib" id="index-fib"></a>

  <p>Rewrite rules provide an interesting way to define your own
  functions. Suppose we want to define
  &lsquo;<samp>fib(n)</samp>&rsquo; to produce the <var>n</var>th
  Fibonacci number. The first two Fibonacci numbers are each 1;
  later numbers are formed by summing the two preceding numbers in
  the sequence. This is easy to express in a set of three
  rules:</p>

  <div class="smallexample">
    <pre class="smallexample">
' [fib(1) := 1, fib(2) := 1, fib(n) := fib(n-1) + fib(n-2)] <span class="key">RET</span>  s t fib

1:  fib(7)               1:  13
    .                        .

    ' fib(7) <span class=
"key">RET</span>             a r fib <span class="key">RET</span>
</pre>
  </div>

  <p>One thing that is guaranteed about the order that rewrites are
  tried is that, for any given subformula, earlier rules in the
  rule set will be tried for that subformula before later ones. So
  even though the first and third rules both match
  &lsquo;<samp>fib(1)</samp>&rsquo;, we know the first will be used
  preferentially.</p>

  <p>This rule set has one dangerous bug: Suppose we apply it to
  the formula &lsquo;<samp>fib(x)</samp>&rsquo;? (Don&rsquo;t
  actually try this.) The third rule will match
  &lsquo;<samp>fib(x)</samp>&rsquo; and replace it with
  &lsquo;<samp><span class=
  "nolinebreak">fib(x-1)</span>&nbsp;+&nbsp;<span class=
  "nolinebreak">fib(x-2)</span></samp>&rsquo;<!-- /@w -->. Each of
  these will then be replaced to get &lsquo;<samp>fib(x-2) + 2
  fib(x-3) + fib(x-4)</samp>&rsquo;, and so on, expanding forever.
  What we really want is to apply the third rule only when
  &lsquo;<samp>n</samp>&rsquo; is an integer greater than two. Type
  <kbd>s&nbsp;e&nbsp;fib&nbsp;<span class="key">RET</span></kbd>
  <!-- /@w -->, then edit the third rule to:</p>

  <div class="smallexample">
    <pre class="smallexample">
fib(n) := fib(n-1) + fib(n-2) :: integer(n) :: n &gt; 2
</pre>
  </div>

  <p>Now:</p>

  <div class="smallexample">
    <pre class="smallexample">
1:  fib(6) + fib(x) + fib(0)      1:  fib(x) + fib(0) + 8
    .                                 .

    ' fib(6)+fib(x)+fib(0) <span class=
"key">RET</span>        a r fib <span class="key">RET</span>
</pre>
  </div>

  <p>We&rsquo;ve created a new function, <code>fib</code>, and a
  new command, <kbd>a&nbsp;r&nbsp;fib&nbsp;<span class=
  "key">RET</span></kbd><!-- /@w -->, which means &ldquo;evaluate
  all <code>fib</code> calls in this formula.&rdquo; To make things
  easier still, we can tell Calc to apply these rules automatically
  by storing them in the special variable
  <code>EvalRules</code>.</p>

  <div class="smallexample">
    <pre class="smallexample">
1:  [fib(1) := ...]    .                1:  [8, 13]
    .                                       .

    s r fib <span class=
"key">RET</span>        s t EvalRules <span class=
"key">RET</span>    ' [fib(6), fib(7)] <span class="key">RET</span>
</pre>
  </div>

  <p>It turns out that this rule set has the problem that it does
  far more work than it needs to when &lsquo;<samp>n</samp>&rsquo;
  is large. Consider the first few steps of the computation of
  &lsquo;<samp>fib(6)</samp>&rsquo;:</p>

  <div class="smallexample">
    <pre class="smallexample">
fib(6) =
fib(5)              +               fib(4) =
fib(4)     +      fib(3)     +      fib(3)     +      fib(2) =
fib(3) + fib(2) + fib(2) + fib(1) + fib(2) + fib(1) + 1 = ...
</pre>
  </div>

  <p>Note that &lsquo;<samp>fib(3)</samp>&rsquo; appears three
  times here. Unless Calc&rsquo;s algebraic simplifier notices the
  multiple &lsquo;<samp>fib(3)</samp>&rsquo;s and combines them
  (and, as it happens, it doesn&rsquo;t), this rule set does lots
  of needless recomputation. To cure the problem, type <code>s e
  EvalRules</code> to edit the rules (or just <kbd>s E</kbd>, a
  shorthand command for editing <code>EvalRules</code>) and add
  another condition:</p>

  <div class="smallexample">
    <pre class="smallexample">
fib(n) := fib(n-1) + fib(n-2) :: integer(n) :: n &gt; 2 :: remember
</pre>
  </div>

  <p>If a &lsquo;<samp>:: remember</samp>&rsquo; condition appears
  anywhere in a rule, then if that rule succeeds Calc will add
  another rule that describes that match to the front of the rule
  set. (Remembering works in any rule set, but for technical
  reasons it is most effective in <code>EvalRules</code>.) For
  example, if the rule rewrites &lsquo;<samp>fib(7)</samp>&rsquo;
  to something that evaluates to 13, then the rule
  &lsquo;<samp>fib(7) := 13</samp>&rsquo; will be added to the rule
  set.</p>

  <p>Type <kbd>' fib(8) <span class="key">RET</span></kbd> to
  compute the eighth Fibonacci number, then type <kbd>s E</kbd>
  again to see what has happened to the rule set.</p>

  <p>With the <code>remember</code> feature, our rule set can now
  compute &lsquo;<samp>fib(<var>n</var>)</samp>&rsquo; in just
  <var>n</var> steps. In the process it builds up a table of all
  Fibonacci numbers up to <var>n</var>. After we have computed the
  result for a particular <var>n</var>, we can get it back (and the
  results for all smaller <var>n</var>) later in just one step.</p>

  <p>All Calc operations will run somewhat slower whenever
  <code>EvalRules</code> contains any rules. You should type <kbd>s
  u EvalRules <span class="key">RET</span></kbd> now to un-store
  the variable.</p>

  <p>(&bull;) <strong>Exercise 2.</strong> Sometimes it is possible
  to reformulate a problem to reduce the amount of recursion
  necessary to solve it. Create a rule that, in about <var>n</var>
  simple steps and without recourse to the <code>remember</code>
  option, replaces &lsquo;<samp>fib(<var>n</var>, 1,
  1)</samp>&rsquo; with &lsquo;<samp>fib(1, <var>x</var>,
  <var>y</var>)</samp>&rsquo; where <var>x</var> and <var>y</var>
  are the <var>n</var>th and <var>n+1</var>st Fibonacci numbers,
  respectively. This rule is rather clunky to use, so add a couple
  more rules to make the &ldquo;user interface&rdquo; the same as
  for our first version: enter
  &lsquo;<samp>fib(<var>n</var>)</samp>&rsquo;, get back a plain
  number. See <a href=
  "Rewrites-Answer-2.html#Rewrites-Answer-2">2</a>. (&bull;)</p>

  <p>There are many more things that rewrites can do. For example,
  there are &lsquo;<samp>&amp;&amp;&amp;</samp>&rsquo; and
  &lsquo;<samp>|||</samp>&rsquo; pattern operators that create
  &ldquo;and&rdquo; and &ldquo;or&rdquo; combinations of rules. As
  one really simple example, we could combine our first two
  Fibonacci rules thusly:</p>

  <div class="example">
    <pre class="example">
[fib(1 ||| 2) := 1, fib(n) := ... ]
</pre>
  </div>

  <p>That means &ldquo;<code>fib</code> of something matching
  either 1 or 2 rewrites to 1.&rdquo;</p>

  <p>You can also make meta-variables optional by enclosing them in
  <code>opt</code>. For example, the pattern &lsquo;<samp>a + b
  x</samp>&rsquo; matches &lsquo;<samp>2 + 3 x</samp>&rsquo; but
  not &lsquo;<samp>2 + x</samp>&rsquo; or &lsquo;<samp>3
  x</samp>&rsquo; or &lsquo;<samp>x</samp>&rsquo;. The pattern
  &lsquo;<samp>opt(a) + opt(b) x</samp>&rsquo; matches all of these
  forms, filling in a default of zero for
  &lsquo;<samp>a</samp>&rsquo; and one for
  &lsquo;<samp>b</samp>&rsquo;.</p>

  <p>(&bull;) <strong>Exercise 3.</strong> Your friend Joe had
  &lsquo;<samp>2 + 3 x</samp>&rsquo; on the stack and tried to use
  the rule &lsquo;<samp>opt(a) + opt(b) x := f(a, b,
  x)</samp>&rsquo;. What happened? See <a href=
  "Rewrites-Answer-3.html#Rewrites-Answer-3">3</a>. (&bull;)</p>

  <p>(&bull;) <strong>Exercise 4.</strong> Starting with a positive
  integer &lsquo;<samp>a</samp>&rsquo;, divide
  &lsquo;<samp>a</samp>&rsquo; by two if it is even, otherwise
  compute &lsquo;<samp>3 a + 1</samp>&rsquo;. Now repeat this step
  over and over. A famous unproved conjecture is that for any
  starting &lsquo;<samp>a</samp>&rsquo;, the sequence always
  eventually reaches 1. Given the formula
  &lsquo;<samp>seq(<var>a</var>, 0)</samp>&rsquo;, write a set of
  rules that convert this into &lsquo;<samp>seq(1,
  <var>n</var>)</samp>&rsquo; where <var>n</var> is the number of
  steps it took the sequence to reach the value 1. Now enhance the
  rules to accept &lsquo;<samp>seq(<var>a</var>)</samp>&rsquo; as a
  starting configuration, and to stop with just the number
  <var>n</var> by itself. Now make the result be a vector of values
  in the sequence, from <var>a</var> to 1. (The formula
  &lsquo;<samp><var>x</var>|<var>y</var></samp>&rsquo; appends the
  vectors <var>x</var> and <var>y</var>.) For example, rewriting
  &lsquo;<samp>seq(6)</samp>&rsquo; should yield the vector
  &lsquo;<samp>[6, 3, 10, 5, 16, 8, 4, 2, 1]</samp>&rsquo;. See
  <a href="Rewrites-Answer-4.html#Rewrites-Answer-4">4</a>.
  (&bull;)</p>

  <p>(&bull;) <strong>Exercise 5.</strong> Define, using rewrite
  rules, a function &lsquo;<samp>nterms(<var>x</var>)</samp>&rsquo;
  that returns the number of terms in the sum <var>x</var>, or 1 if
  <var>x</var> is not a sum. (A <em>sum</em> for our purposes is
  one or more non-sum terms separated by
  &lsquo;<samp>+</samp>&rsquo; or &lsquo;<samp>-</samp>&rsquo;
  signs, so that &lsquo;<samp>2 - 3 (x + y) + x y</samp>&rsquo; is
  a sum of three terms.) See <a href=
  "Rewrites-Answer-5.html#Rewrites-Answer-5">5</a>. (&bull;)</p>

  <p>(&bull;) <strong>Exercise 6.</strong> A Taylor series for a
  function is an infinite series that exactly equals the value of
  that function at values of &lsquo;<samp>x</samp>&rsquo; near
  zero.</p>

  <div class="example">
    <pre class="example">
cos(x) = 1 - x^2 / 2! + x^4 / 4! - x^6 / 6! + ...
</pre>
  </div>

  <p>The <kbd>a t</kbd> command produces a <em>truncated Taylor
  series</em> which is obtained by dropping all the terms higher
  than, say, &lsquo;<samp>x^2</samp>&rsquo;. Calc represents the
  truncated Taylor series as a polynomial in
  &lsquo;<samp>x</samp>&rsquo;. Mathematicians often write a
  truncated series using a &ldquo;big-O&rdquo; notation that
  records what was the lowest term that was truncated.</p>

  <div class="example">
    <pre class="example">
cos(x) = 1 - x^2 / 2! + O(x^3)
</pre>
  </div>

  <p>The meaning of &lsquo;<samp>O(x^3)</samp>&rsquo; is &ldquo;a
  quantity which is negligibly small if
  &lsquo;<samp>x^3</samp>&rsquo; is considered negligibly small as
  &lsquo;<samp>x</samp>&rsquo; goes to zero.&rdquo;</p>

  <p>The exercise is to create rewrite rules that simplify sums and
  products of power series represented as
  &lsquo;<samp><var>polynomial</var> +
  O(<var>var</var>^<var>n</var>)</samp>&rsquo;. For example, given
  &lsquo;<samp>1 - x^2 / 2 + O(x^3)</samp>&rsquo; and
  &lsquo;<samp>x - x^3 / 6 + O(x^4)</samp>&rsquo; on the stack, we
  want to be able to type <kbd>*</kbd> and get the result
  &lsquo;<samp>x - 2:3 x^3 + O(x^4)</samp>&rsquo;. Don&rsquo;t
  worry if the terms of the sum are rearranged. (This one is rather
  tricky; the solution at the end of this chapter uses 6 rewrite
  rules. Hint: The &lsquo;<samp>constant(x)</samp>&rsquo; condition
  tests whether &lsquo;<samp>x</samp>&rsquo; is a number.) See
  <a href="Rewrites-Answer-6.html#Rewrites-Answer-6">6</a>.
  (&bull;)</p>

  <p>Just for kicks, try adding the rule <code>2+3 := 6</code> to
  <code>EvalRules</code>. What happens? (Be sure to remove this
  rule afterward, or you might get a nasty surprise when you use
  Calc to balance your checkbook!)</p>

  <p>See <a href="Rewrite-Rules.html#Rewrite-Rules">Rewrite
  Rules</a>, for the whole story on rewrite rules.</p>
  <hr />

  <div class="header">
    <p>Previous: <a href=
    "Basic-Algebra-Tutorial.html#Basic-Algebra-Tutorial" accesskey=
    "p" rel="prev">Basic Algebra Tutorial</a>, Up: <a href=
    "Algebra-Tutorial.html#Algebra-Tutorial" accesskey="u" rel=
    "up">Algebra Tutorial</a> &nbsp; [<a href=
    "index.html#SEC_Contents" title="Table of contents" rel=
    "contents">Contents</a>][<a href="Key-Index.html#Key-Index"
    title="Index" rel="index">Index</a>]</p>
  </div>
</body>
</html>
